        -:    0:Source:D:/programming/projects/cpp-labs/lab1/src/bitarray.cpp
        -:    0:Graph:D:\programming\projects\cpp-labs\lab1\cmake-build-debug-coverage\CMakeFiles\lab1_test.dir\test\test1.cpp.gcno
        -:    0:Data:D:\programming\projects\cpp-labs\lab1\cmake-build-debug-coverage\CMakeFiles\lab1_test.dir\test\test1.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "bitarray.h"
        -:    2:
        -:    3:#define full_true 255
        -:    4:
function _ZN8BitArrayC2Ev called 1 returned 100% blocks executed 100%
        1:    5:BitArray::BitArray() : _capacity(0), _cur_size(0), _array(nullptr){};
        -:    6:
function _ZN8BitArrayD2Ev called 20 returned 100% blocks executed 100%
       20:    7:BitArray::~BitArray(){
       20:    8:  delete[] _array;
       20:    8-block  0
branch  0 taken 18 (fallthrough)
branch  1 taken 2
       18:    8-block  1
call    2 returned 18
       20:    9:};
        -:   10:
function _ZN8BitArrayC2Eih called 17 returned 100% blocks executed 88%
       17:   11:BitArray::BitArray(int num_bits, unsigned char value){
      17*:   12:  if(num_bits < 0) return;
       17:   12-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 17
    %%%%%:   12-block  1
       17:   13:  if(num_bits % type_size == 0) _capacity = num_bits;
       17:   13-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 9
        8:   13-block  1
        9:   14:  else _capacity = num_bits + (type_size-(num_bits % type_size));
        9:   14-block  0
       17:   15:  _cur_size = num_bits;
       17:   16:  _array = new unsigned char[_capacity / type_size];
       17:   16-block  0
call    0 returned 17
       17:   17:  _array[0] = value;
        -:   18:}
        -:   19:
function _ZN8BitArrayC2ERKS_ called 2 returned 100% blocks executed 100%
        2:   20:BitArray::BitArray(const BitArray& b) {
        2:   21:  auto* tmp = new unsigned char[b._capacity / type_size];
        2:   21-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        5:   22:  for(size_t i = 0; i < b._capacity / type_size; ++i){
        2:   22-block  0
        5:   22-block  1
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3:   23:    tmp[i] = b._array[i];
        3:   23-block  0
        -:   24:  }
        -:   25:
        2:   26:  _array = std::move(tmp);
        2:   26-block  0
call    0 returned 2
        2:   27:  _capacity = b._capacity;
        2:   28:  _cur_size = b._cur_size;
        2:   29:};
        -:   30:
function _ZN8BitArray4swapERS_ called 1 returned 100% blocks executed 100%
        1:   31:void BitArray::swap(BitArray& b){
        1:   32:  std::swap(_array, b._array);
        1:   32-block  0
call    0 returned 1
        -:   33:
        1:   34:  size_t tmp_cap = b._capacity;
        1:   35:  size_t tmp_csize = b._cur_size;
        -:   36:
        1:   37:  b._capacity = _capacity;
        1:   38:  b._cur_size = _cur_size;
        -:   39:
        1:   40:  _capacity = tmp_cap;
        1:   41:  _cur_size = tmp_csize;
        1:   42:};
        -:   43:
function _ZN8BitArrayaSERKS_ called 2 returned 100% blocks executed 100%
        2:   44:BitArray& BitArray::operator=(const BitArray& b){
        2:   45:  auto* tmp = new unsigned char[b._capacity / type_size];
        2:   45-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        5:   46:  for(size_t i = 0; i < b._capacity / type_size; ++i){
        2:   46-block  0
        5:   46-block  1
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3:   47:    tmp[i] = b._array[i];
        3:   47-block  0
        -:   48:  }
        -:   49:
        2:   50:  _array = std::move(tmp);
        2:   50-block  0
call    0 returned 2
        2:   51:  _capacity = b._capacity;
        2:   52:  _cur_size = b._cur_size;
        -:   53:
        2:   54:  return *this;
        2:   54-block  0
        -:   55:};
        -:   56:
        -:   57:
        -:   58://доделать для num_bits < или == cur_size
function _ZN8BitArray6resizeEib called 2 returned 100% blocks executed 100%
        2:   59:void BitArray::resize(int num_bits, bool value){
        -:   60:  size_t new_capacity;
        2:   61:  if(num_bits % type_size == 0) new_capacity = num_bits;
        2:   61-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   61-block  1
        1:   62:  else new_capacity = num_bits + (type_size-(num_bits % type_size));
        1:   62-block  0
        2:   63:  auto tmp = new unsigned char[new_capacity / type_size];
        2:   63-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        6:   64:  for(size_t i = 0; i != _capacity / type_size; ++i){
        2:   64-block  0
        6:   64-block  1
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:   65:    tmp[i] = _array[i];
        4:   65-block  0
        -:   66:  }
        -:   67:
        2:   68:  _cur_size = num_bits;
        2:   69:  _capacity = new_capacity;
        2:   70:  _array = std::move(tmp);
        2:   70-block  0
call    0 returned 2
        2:   71:}
        -:   72:
function _ZN8BitArray5clearEv called 1 returned 100% blocks executed 100%
        1:   73:void BitArray::clear(){
        1:   74:  delete[] _array;
        1:   74-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   74-block  1
call    2 returned 1
        1:   75:  _capacity = 0;
        1:   76:  _cur_size = 0;
        1:   77:  _array = nullptr;
        1:   78:}
        -:   79:
function _ZN8BitArray9push_backEb called 2 returned 100% blocks executed 100%
        2:   80:void BitArray::push_back(bool bit){
        2:   81:  if(_capacity == _cur_size){
        2:   81-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   82:    size_t tmp = _cur_size;
        1:   83:    resize(static_cast<int>(_capacity * resizing_rate));
        1:   83-block  0
call    0 returned 1
        1:   84:    set(static_cast<int>(tmp), bit);
call    0 returned 1
        1:   85:    _cur_size++;
        -:   86:  }else{
        1:   87:    set(static_cast<int>(_cur_size), bit);
        1:   87-block  0
call    0 returned 1
        1:   88:    _cur_size++;
        -:   89:  };
        2:   90:}
        -:   91:
function _ZN8BitArrayaNERKS_ called 2 returned 100% blocks executed 100%
        2:   92:BitArray& BitArray::operator&=(const BitArray& b){
        2:   93:  auto tmp = new unsigned char[b._capacity / type_size];
        2:   93-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        4:   94:  for(size_t i = 0; i < b._capacity / type_size; ++i){
        2:   94-block  0
        4:   94-block  1
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        2:   95:    tmp[i] &= b._array[i];
        2:   95-block  0
        -:   96:  }
        2:   97:  _array = std::move(tmp);
        2:   97-block  0
call    0 returned 2
        2:   98:  return *this;
        2:   98-block  0
        -:   99:}
        -:  100:
function _ZN8BitArrayoRERKS_ called 0 returned 0% blocks executed 0%
    #####:  101:BitArray& BitArray::operator|=(const BitArray& b){
    #####:  102:  auto tmp = new unsigned char[b._capacity / type_size];
    %%%%%:  102-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  103:  for(size_t i = 0; i < b._capacity / type_size; ++i){
    %%%%%:  103-block  0
    %%%%%:  103-block  1
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  104:    tmp[i] |= b._array[i];
    %%%%%:  104-block  0
        -:  105:  }
    #####:  106:  _array = std::move(tmp);
    %%%%%:  106-block  0
call    0 never executed
    #####:  107:  return *this;
    %%%%%:  107-block  0
        -:  108:}
        -:  109:
function _ZN8BitArrayeOERKS_ called 0 returned 0% blocks executed 0%
    #####:  110:BitArray& BitArray::operator^=(const BitArray& b){
    #####:  111:  auto tmp = new unsigned char[b._capacity / type_size];
    %%%%%:  111-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  112:  for(size_t i = 0; i < b._capacity / type_size; ++i){
    %%%%%:  112-block  0
    %%%%%:  112-block  1
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  113:    tmp[i] ^= b._array[i];
    %%%%%:  113-block  0
        -:  114:  }
    #####:  115:  _array = std::move(tmp);
    %%%%%:  115-block  0
call    0 never executed
    #####:  116:  return *this;
    %%%%%:  116-block  0
        -:  117:}
        -:  118:
        -:  119://Битовый сдвиг с заполнением нулями.
function _ZN8BitArraylSEi called 0 returned 0% blocks executed 0%
    #####:  120:BitArray& BitArray::operator<<=(int n){
    #####:  121:  return *this;
    %%%%%:  121-block  0
        -:  122:}
function _ZN8BitArrayrSEi called 0 returned 0% blocks executed 0%
    #####:  123:BitArray& BitArray::operator>>=(int n){
    #####:  124:  return *this;
    %%%%%:  124-block  0
        -:  125:}
function _ZNK8BitArraylsEi called 0 returned 0% blocks executed 0%
    #####:  126:BitArray BitArray::operator<<(int n) const{
    #####:  127:  return *this;
    %%%%%:  127-block  0
call    0 never executed
        -:  128:}
function _ZNK8BitArrayrsEi called 0 returned 0% blocks executed 0%
    #####:  129:BitArray BitArray::operator>>(int n) const{
    #####:  130:  return *this;
    %%%%%:  130-block  0
call    0 never executed
        -:  131:}
        -:  132:
        -:  133:
        -:  134://Устанавливает бит с индексом n в значение val.
function _ZN8BitArray3setEib called 13 returned 100% blocks executed 100%
       13:  135:BitArray& BitArray::set(int n, bool val){
       13:  136:  if(val) _array[n / type_size] |= mask(n);
       13:  136-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 3
       10:  136-block  1
call    2 returned 10
        3:  137:  else _array[n / type_size] &= ~mask(n);
        3:  137-block  0
call    0 returned 3
       13:  138:  return *this;
       13:  138-block  0
        -:  139:}
        -:  140://Заполняет массив истиной.
function _ZN8BitArray3setEv called 8 returned 100% blocks executed 100%
        8:  141:BitArray& BitArray::set(){
       20:  142:  for(size_t i = 0; i < _capacity / type_size; ++i){
        8:  142-block  0
       20:  142-block  1
branch  0 taken 12
branch  1 taken 8 (fallthrough)
       12:  143:    _array[i] = full_true;
       12:  143-block  0
        -:  144:  }
        8:  145:  return *this;
        8:  145-block  0
        -:  146:}
        -:  147:
        -:  148://Устанавливает бит с индексом n в значение false.
function _ZN8BitArray5resetEi called 1 returned 100% blocks executed 100%
        1:  149:BitArray& BitArray::reset(int n){
        1:  150:  set(n, false);
        1:  150-block  0
call    0 returned 1
        1:  151:  return *this;
        -:  152:}
        -:  153://Заполняет массив ложью.
function _ZN8BitArray5resetEv called 5 returned 100% blocks executed 100%
        5:  154:BitArray& BitArray::reset(){
       12:  155:  for(size_t i = 0; i < _capacity / type_size; ++i){
        5:  155-block  0
       12:  155-block  1
branch  0 taken 7
branch  1 taken 5 (fallthrough)
        7:  156:    _array[i] = 0;
        7:  156-block  0
        -:  157:  }
        5:  158:  return *this;
        5:  158-block  0
        -:  159:}
        -:  160:
        -:  161://true, если массив содержит истинный бит.
function _ZNK8BitArray3anyEv called 4 returned 100% blocks executed 100%
        4:  162:bool BitArray::any() const{
        6:  163:  for(size_t i = 0; i < _capacity / type_size; ++i){
        4:  163-block  0
        2:  163-block  1
        6:  163-block  2
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  164:    if(_array[i] != 0){
        4:  164-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  165:      return true;
        2:  165-block  0
        -:  166:    }
        -:  167:  }
        2:  168:  return false;
        2:  168-block  0
        -:  169:}
        -:  170://true, если все биты массива ложны.
function _ZNK8BitArray4noneEv called 2 returned 100% blocks executed 100%
        2:  171:bool BitArray::none() const{
        2:  172:  return !any();
        2:  172-block  0
call    0 returned 2
        -:  173:}
        -:  174://Битовая инверсия
function _ZNK8BitArraycoEv called 1 returned 100% blocks executed 100%
        1:  175:BitArray BitArray::operator~() const{
        2:  176:  for(size_t i = 0; i < _capacity / type_size; ++i){
        1:  176-block  0
        2:  176-block  1
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1:  177:    _array[i] = ~_array[i];
        1:  177-block  0
        -:  178:  }
        1:  179:  return *this;
        1:  179-block  0
call    0 returned 1
        -:  180:}
        -:  181://Подсчитывает количество единичных бит.
function _ZNK8BitArray5countEv called 3 returned 100% blocks executed 100%
        3:  182:int BitArray::count() const{
        3:  183:  int counter = 0;
        6:  184:  for(size_t i = 0; i != _capacity / type_size; ++i){
        3:  184-block  0
        3:  184-block  1
        6:  184-block  2
branch  0 taken 3
branch  1 taken 3 (fallthrough)
       27:  185:    for(size_t k = 0; k < type_size; ++k){
        3:  185-block  0
       24:  185-block  1
       27:  185-block  2
branch  0 taken 24
branch  1 taken 3 (fallthrough)
       24:  186:      if((_array[i] & mask(k)) != 0) counter++;
       24:  186-block  0
call    0 returned 24
branch  1 taken 4 (fallthrough)
branch  2 taken 20
        4:  186-block  1
        -:  187:    }
        -:  188:  }
        3:  189:  return counter;
        3:  189-block  0
        -:  190:}
        -:  191:
        -:  192:
        -:  193://Возвращает значение бита по индексу i.
function _ZNK8BitArrayixEi called 25 returned 100% blocks executed 100%
       25:  194:bool BitArray::operator[](int i) const{
       25:  195:  return (mask(i) & _array[i/8]) != 0;
       25:  195-block  0
call    0 returned 25
        -:  196:}
        -:  197:
function _ZNK8BitArray4sizeEv called 6 returned 100% blocks executed 100%
        6:  198:int BitArray::size() const{
        6:  199:  return (int)_cur_size;
        6:  199-block  0
        -:  200:}
        -:  201:
function _ZNK8BitArray5emptyEv called 2 returned 100% blocks executed 100%
        2:  202:bool BitArray::empty() const{
        2:  203:  if(_cur_size == 0) return true;
        2:  203-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  203-block  1
        1:  204:  return false;
        1:  204-block  0
        -:  205:}
        -:  206:
        -:  207://Возвращает строковое представление массива.
function _ZNK8BitArray9to_stringB5cxx11Ev called 1 returned 100% blocks executed 93%
        1:  208:std::string BitArray::to_string() const{
        1:  209:  std::string str;
        1:  209-block  0
call    0 returned 1
        2:  210:  for(size_t i = 0; i < _capacity / type_size; ++i){
        1:  210-block  0
        2:  210-block  1
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        9:  211:    for(size_t k = 0; k < type_size; ++k){
        1:  211-block  0
        8:  211-block  1
        9:  211-block  2
branch  0 taken 8
branch  1 taken 1 (fallthrough)
        8:  212:      if((_array[i] & mask(k)) != 0) str.push_back('1');
        8:  212-block  0
call    0 returned 8
branch  1 taken 3 (fallthrough)
branch  2 taken 5
        3:  212-block  1
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
        5:  213:      else str.push_back('0');
        5:  213-block  0
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        -:  214:    }
        -:  215:  }
        1:  216:  return str;
        1:  216-block  0
        1:  216-block  1
    =====:  217:}
    $$$$$:  217-block  0
call    0 never executed
